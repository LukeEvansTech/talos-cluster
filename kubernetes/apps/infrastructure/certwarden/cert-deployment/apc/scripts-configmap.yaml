apiVersion: v1
data:
  apc-updater.py: |
    #!/usr/bin/env python3

    # vim: autoindent tabstop=4 shiftwidth=4 expandtab softtabstop=4 filetype=python

    # This file is part of APC NMC certificate updater.
    # APC NMC certificate updater is free software: you can
    # redistribute it and/or modify it under the terms of the GNU General Public
    # License as published by the Free Software Foundation, version 2.
    #
    # This program is distributed in the hope that it will be useful, but WITHOUT
    # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
    # FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
    # details.
    #
    # You should have received a copy of the GNU General Public License along with
    # this program; if not, write to the Free Software Foundation, Inc., 51
    # Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

    import os
    import sys
    import argparse
    import subprocess
    import tempfile
    import logging

    REQUEST_TIMEOUT = 30.0

    class APCUpdater:
        def __init__(self, hostname, username, password, fingerprint, apc_tool_path,
                     insecure_cipher=False, debug=False):
            self.hostname = hostname
            self.username = username
            self.password = password
            self.fingerprint = fingerprint
            self.apc_tool_path = apc_tool_path
            self.insecure_cipher = insecure_cipher
            self.debug = debug

            # Setup logging
            log_level = logging.DEBUG if debug else logging.INFO
            logging.basicConfig(
                level=log_level,
                format='%(asctime)s - %(levelname)s - %(message)s'
            )
            self.logger = logging.getLogger("APCUpdater")

        def install_cert(self, key_file, cert_file):
            """
            Install certificate to APC NMC using apc-p15-tool
            :param key_file: filename to X.509 certificate private key
            :param cert_file: filename to X.509 certificate PEM
            :return: bool
            """
            self.logger.info(f"Installing certificate to APC NMC at {self.hostname}")
            self.logger.debug(f"Reading certificate from {cert_file}")
            self.logger.debug(f"Reading key from {key_file}")

            # Verify files exist
            if not os.path.isfile(key_file):
                self.logger.error(f"Key file '{key_file}' doesn't exist!")
                return False
            if not os.path.isfile(cert_file):
                self.logger.error(f"Certificate file '{cert_file}' doesn't exist!")
                return False

            # Build the apc-p15-tool command
            cmd = [
                self.apc_tool_path,
                'install',
                '--keyfile', key_file,
                '--certfile', cert_file,
                '--hostname', self.hostname,
                '--username', self.username,
                '--password', self.password,
                '--fingerprint', self.fingerprint
            ]

            # Add insecure cipher flag if needed (required for older APC devices with cryptlib SSH)
            if self.insecure_cipher:
                cmd.append('--insecurecipher')
                self.logger.warning("Using --insecurecipher flag for legacy SSH support")

            if self.debug:
                cmd.append('--debug')

            self.logger.debug(f"Executing command: {' '.join(cmd[:7])} [credentials hidden]")

            try:
                # Run the apc-p15-tool command
                result = subprocess.run(
                    cmd,
                    capture_output=True,
                    text=True,
                    timeout=REQUEST_TIMEOUT
                )

                # Log output
                if result.stdout:
                    self.logger.info(f"apc-p15-tool output:\n{result.stdout}")
                if result.stderr:
                    self.logger.warning(f"apc-p15-tool stderr:\n{result.stderr}")

                # Check if certificate was installed successfully
                # The tool may return non-zero if verification fails, but install can still succeed
                if "apc p15 file installed" in result.stdout:
                    self.logger.info("✅ Certificate installed successfully!")
                    if "failed to dial webui for verification" in result.stderr:
                        self.logger.warning("⚠️  Web UI verification failed (this is OK - cert is installed)")
                    return True

                # If we didn't find the success message, check the return code
                if result.returncode != 0:
                    self.logger.error(f"apc-p15-tool failed with return code {result.returncode}")
                    return False

                self.logger.info("✅ Certificate installed successfully!")
                return True

            except subprocess.TimeoutExpired:
                self.logger.error(f"apc-p15-tool timed out after {REQUEST_TIMEOUT} seconds")
                return False
            except Exception as e:
                self.logger.error(f"Failed to execute apc-p15-tool: {e}")
                return False


    def main():
        parser = argparse.ArgumentParser(description='Update APC NMC SSL certificate')
        parser.add_argument('--hostname', required=True,
                            help='APC NMC hostname or IP address')
        parser.add_argument('--username', required=True,
                            help='APC NMC username with admin access')
        parser.add_argument('--password', required=True,
                            help='APC NMC user password')
        parser.add_argument('--fingerprint', required=True,
                            help='APC NMC SSH host key fingerprint')
        parser.add_argument('--key-file', required=True,
                            help='X.509 Private key filename')
        parser.add_argument('--cert-file', required=True,
                            help='X.509 Certificate filename')
        parser.add_argument('--apc-tool-path', default='/usr/local/bin/apc-p15-tool',
                            help='Path to apc-p15-tool binary (default: /usr/local/bin/apc-p15-tool)')
        parser.add_argument('--insecure-cipher', action='store_true',
                            help='Use insecure ciphers for older APC devices (--insecurecipher)')
        parser.add_argument('--quiet', action='store_true',
                            help='Do not output anything if successful')
        parser.add_argument('--debug', action='store_true',
                            help='Output additional debugging')
        args = parser.parse_args()

        # Confirm args
        if not os.path.isfile(args.key_file):
            print(f"--key-file '{args.key_file}' doesn't exist!")
            sys.exit(2)
        if not os.path.isfile(args.cert_file):
            print(f"--cert-file '{args.cert_file}' doesn't exist!")
            sys.exit(2)
        if not os.path.isfile(args.apc_tool_path):
            print(f"apc-p15-tool not found at '{args.apc_tool_path}'!")
            print("Make sure the apc-p15-tool binary is installed")
            sys.exit(2)

        # Create updater
        updater = APCUpdater(
            hostname=args.hostname,
            username=args.username,
            password=args.password,
            fingerprint=args.fingerprint,
            apc_tool_path=args.apc_tool_path,
            insecure_cipher=args.insecure_cipher,
            debug=args.debug
        )

        # Install certificate
        if not updater.install_cert(args.key_file, args.cert_file):
            print("Failed to install certificate to APC NMC!")
            sys.exit(2)

        if not args.quiet:
            print("All done!")

        sys.exit(0)


    if __name__ == "__main__":
        main()
  certwarden-apc-deploy.sh: |
    #!/bin/bash
    #
    # Certwarden Post-Process Script for APC NMC Certificate Deployment
    #
    # This script is called by Certwarden after certificate renewal.
    # It creates a Kubernetes Job to deploy the certificate to the APC NMC device.
    #
    # Environment variables from Certwarden:
    #   CERTIFICATE_NAME - Name of the certificate
    #   CERTIFICATE_PEM - Certificate data (PEM format)
    #   PRIVATE_KEY_PEM - Private key data (PEM format)
    #   APC_HOST - Custom env var: APC host identifier (e.g., ups-main)
    #   NAMESPACE - Optional: Kubernetes namespace (default: infrastructure)
    #

    set -euo pipefail

    # Debug output to stderr (Certwarden captures this)
    echo "DEBUG: Script started at $(date)" >&2
    echo "DEBUG: Environment variables:" >&2
    env | grep -E "(APC|CERTIFICATE|PRIVATE|NAMESPACE)" | sort >&2 || echo "DEBUG: No matching env vars" >&2
    echo "DEBUG: Working directory: $(pwd)" >&2
    echo "DEBUG: User: $(whoami)" >&2
    echo "DEBUG: Script path: $0" >&2

    # Validate required environment variables FIRST (before using them with set -u)
    if [[ -z "${APC_HOST:-}" ]]; then
        echo "ERROR: APC_HOST environment variable is required" >&2
        exit 1
    fi

    if [[ -z "${CERTIFICATE_PEM:-}" ]]; then
        echo "ERROR: CERTIFICATE_PEM not provided by Certwarden" >&2
        exit 1
    fi

    if [[ -z "${PRIVATE_KEY_PEM:-}" ]]; then
        echo "ERROR: PRIVATE_KEY_PEM not provided by Certwarden" >&2
        exit 1
    fi

    # Now safe to use variables with set -u
    echo "DEBUG: Setting NAMESPACE and SECRET_NAME..." >&2
    NAMESPACE="${NAMESPACE:-infrastructure}"
    SECRET_NAME="apc-${APC_HOST}"
    echo "DEBUG: NAMESPACE=${NAMESPACE}, SECRET_NAME=${SECRET_NAME}" >&2

    echo "=== Certwarden APC NMC Certificate Deployment ===" >&2
    echo "Certificate: ${CERTIFICATE_NAME:-unknown}" >&2
    echo "Target APC: ${APC_HOST}" >&2
    echo "Namespace: ${NAMESPACE}" >&2

    # Create a unique job name with timestamp
    JOB_NAME="apc-cert-deploy-${APC_HOST}-$(date +%s)"

    # Create a temporary secret for the certificate
    CERT_SECRET_NAME="${JOB_NAME}-cert"
    echo "Creating temporary secret: ${CERT_SECRET_NAME}" >&2

    kubectl create secret generic "${CERT_SECRET_NAME}" \
        -n "${NAMESPACE}" \
        --from-literal=cert.pem="${CERTIFICATE_PEM}" \
        --from-literal=key.pem="${PRIVATE_KEY_PEM}"

    # Note: Secret cleanup is handled by the Job's ownerReferences
    # The secret will be garbage collected when the Job is deleted via ttlSecondsAfterFinished

    # Create the deployment Job
    echo "Creating deployment Job: ${JOB_NAME}" >&2
    cat <<EOF | kubectl apply -f -
    apiVersion: batch/v1
    kind: Job
    metadata:
      name: ${JOB_NAME}
      namespace: ${NAMESPACE}
      labels:
        app.kubernetes.io/name: certwarden-apc-deploy
        app.kubernetes.io/instance: ${APC_HOST}
    spec:
      ttlSecondsAfterFinished: 300
      backoffLimit: 2
      template:
        spec:
          serviceAccountName: certwarden
          restartPolicy: Never
          containers:
            - name: apc-deploy
              image: docker.io/python:3.14-alpine
              command:
                - sh
                - -c
                - |
                  set -e

                  # Install dependencies
                  apk add --no-cache curl openssh-client
                  curl -LO "https://dl.k8s.io/release/\$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
                  chmod +x kubectl
                  mv kubectl /usr/local/bin/

                  # Download and install apc-p15-tool
                  echo "=== Downloading apc-p15-tool ==="
                  APC_TOOL_VERSION="v1.3.3"
                  curl -L "https://github.com/gregtwallace/apc-p15-tool/releases/download/\${APC_TOOL_VERSION}/apc-p15-tool-\${APC_TOOL_VERSION}_linux_amd64.tar.gz" -o /tmp/apc-p15-tool.tar.gz
                  tar -xzf /tmp/apc-p15-tool.tar.gz -C /tmp
                  mv /tmp/apc-p15-tool /usr/local/bin/apc-p15-tool
                  chmod +x /usr/local/bin/apc-p15-tool
                  apc-p15-tool version || echo "Tool installed successfully"

                  # Read APC configuration from secret
                  export APC_HOSTNAME=\$(kubectl get secret ${SECRET_NAME} -n ${NAMESPACE} -o jsonpath='{.data.APC_HOSTNAME}' | base64 -d)
                  export APC_USERNAME=\$(kubectl get secret ${SECRET_NAME} -n ${NAMESPACE} -o jsonpath='{.data.APC_USERNAME}' | base64 -d)
                  export APC_PASSWORD=\$(kubectl get secret ${SECRET_NAME} -n ${NAMESPACE} -o jsonpath='{.data.APC_PASSWORD}' | base64 -d)
                  export APC_FINGERPRINT=\$(kubectl get secret ${SECRET_NAME} -n ${NAMESPACE} -o jsonpath='{.data.APC_FINGERPRINT}' | base64 -d)
                  export APC_INSECURE_CIPHER=\$(kubectl get secret ${SECRET_NAME} -n ${NAMESPACE} -o jsonpath='{.data.APC_INSECURE_CIPHER}' | base64 -d || echo "false")

                  echo "=== APC NMC Configuration ==="
                  echo "APC Hostname: \${APC_HOSTNAME}"
                  echo "APC Username: \${APC_USERNAME}"
                  echo "APC Fingerprint: \${APC_FINGERPRINT}"
                  echo "APC Insecure Cipher: \${APC_INSECURE_CIPHER}"

                  # Build command with optional insecure cipher flag
                  INSECURE_FLAG=""
                  if [[ "\${APC_INSECURE_CIPHER}" == "true" ]]; then
                    INSECURE_FLAG="--insecure-cipher"
                    echo "⚠️  Using insecure cipher support for legacy APC devices"
                  fi

                  echo "=== Deploying certificate ==="
                  python3 /scripts/apc-updater.py \\
                    --hostname "\${APC_HOSTNAME}" \\
                    --username "\${APC_USERNAME}" \\
                    --password "\${APC_PASSWORD}" \\
                    --fingerprint "\${APC_FINGERPRINT}" \\
                    --cert-file /certs/cert.pem \\
                    --key-file /certs/key.pem \\
                    --apc-tool-path /usr/local/bin/apc-p15-tool \\
                    \${INSECURE_FLAG} \\
                    --debug
              volumeMounts:
                - name: scripts
                  mountPath: /scripts
                - name: certs
                  mountPath: /certs
          volumes:
            - name: scripts
              configMap:
                name: certwarden-apc-scripts
                defaultMode: 0755
            - name: certs
              secret:
                secretName: ${CERT_SECRET_NAME}
    EOF

    # Wait for the job to complete
    echo "Waiting for Job to complete..." >&2
    kubectl wait --for=condition=complete --timeout=5m "job/${JOB_NAME}" -n "${NAMESPACE}"

    # Get the job logs
    echo "=== Job Logs ===" >&2
    kubectl logs "job/${JOB_NAME}" -n "${NAMESPACE}"

    # Check if the job succeeded
    JOB_STATUS=$(kubectl get job "${JOB_NAME}" -n "${NAMESPACE}" -o jsonpath='{.status.conditions[?(@.type=="Complete")].status}')
    if [[ "${JOB_STATUS}" == "True" ]]; then
        echo "✅ Certificate deployed successfully to ${APC_HOST}" >&2
        exit 0
    else
        echo "❌ Failed to deploy certificate to ${APC_HOST}" >&2
        kubectl logs "job/${JOB_NAME}" -n "${NAMESPACE}" >&2
        exit 1
    fi
kind: ConfigMap
metadata:
  creationTimestamp: null
  name: certwarden-apc-scripts
  namespace: infrastructure
