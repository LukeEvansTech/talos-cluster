---
apiVersion: v1
data:
  certwarden-ipmi-deploy.sh: |
    #!/bin/bash
    #
    # Certwarden Post-Process Script for IPMI Certificate Deployment
    #
    # This script is called by Certwarden after certificate renewal.
    # It creates a Kubernetes Job to deploy the certificate to the IPMI host.
    #
    # Environment variables from Certwarden:
    #   CERTIFICATE_NAME - Name of the certificate
    #   CERTIFICATE_PEM - Certificate data (PEM format)
    #   PRIVATE_KEY_PEM - Private key data (PEM format)
    #   IPMI_HOST - Custom env var: IPMI host identifier (e.g., cr-storage-ipmi)
    #
    # shellcheck disable=SC2157,SC2193,SC2034
    # Note: Variables use $$ syntax for Kustomize escaping, shellcheck can't parse this

    set -euo pipefail

    # Debug output to stderr (Certwarden captures this)
    echo "DEBUG: Script started at $(date)" >&2
    echo "DEBUG: Environment variables:" >&2
    env | grep -E "(IPMI|CERTIFICATE|PRIVATE|NAMESPACE)" | sort >&2 || echo "DEBUG: No matching env vars" >&2
    echo "DEBUG: Working directory: $(pwd)" >&2
    echo "DEBUG: User: $(whoami)" >&2
    echo "DEBUG: Script path: $0" >&2

    # Validate required environment variables FIRST (before using them with set -u)
    if [[ -z "$${IPMI_HOST:-}" ]]; then
        echo "ERROR: IPMI_HOST environment variable is required"
        exit 1
    fi

    if [[ -z "$${CERTIFICATE_PEM:-}" ]]; then
        echo "ERROR: CERTIFICATE_PEM not provided by Certwarden"
        exit 1
    fi

    if [[ -z "$${PRIVATE_KEY_PEM:-}" ]]; then
        echo "ERROR: PRIVATE_KEY_PEM not provided by Certwarden"
        exit 1
    fi

    # Now safe to use variables with set -u
    NAMESPACE="$${NAMESPACE:-infrastructure}"
    SECRET_NAME="ipmi-$${IPMI_HOST}"

    echo "=== Certwarden IPMI Certificate Deployment ==="
    echo "Certificate: $${CERTIFICATE_NAME:-unknown}"
    echo "Target IPMI: $${IPMI_HOST}"
    echo "Namespace: $${NAMESPACE}"

    # Create a unique job name with timestamp
    JOB_NAME="ipmi-cert-deploy-$${IPMI_HOST}-$(date +%s)"

    # Create a temporary secret for the certificate
    CERT_SECRET_NAME="$${JOB_NAME}-cert"
    echo "Creating temporary secret: $${CERT_SECRET_NAME}"

    kubectl create secret generic "$${CERT_SECRET_NAME}" \
        -n "$${NAMESPACE}" \
        --from-literal=cert.pem="$${CERTIFICATE_PEM}" \
        --from-literal=key.pem="$${PRIVATE_KEY_PEM}"

    # Note: Secret cleanup is handled by the Job's ownerReferences
    # The secret will be garbage collected when the Job is deleted via ttlSecondsAfterFinished

    # Create the deployment Job
    echo "Creating deployment Job: $${JOB_NAME}"
    cat <<EOF | kubectl apply -f -
    apiVersion: batch/v1
    kind: Job
    metadata:
      name: $${JOB_NAME}
      namespace: $${NAMESPACE}
      labels:
        app.kubernetes.io/name: certwarden-ipmi-deploy
        app.kubernetes.io/instance: $${IPMI_HOST}
    spec:
      ttlSecondsAfterFinished: 300
      backoffLimit: 2
      template:
        spec:
          serviceAccountName: certwarden
          restartPolicy: Never
          containers:
            - name: ipmi-deploy
              image: docker.io/python:3.12-alpine
              command:
                - sh
                - -c
                - |
                  set -e

                  # Install dependencies
                  apk add --no-cache curl
                  curl -LO "https://dl.k8s.io/release/\$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
                  chmod +x kubectl
                  mv kubectl /usr/local/bin/

                  # Install Python packages
                  pip3 install --no-cache-dir requests pyOpenSSL

                  # Read IPMI configuration from secret
                  export IPMI_URL=\$(kubectl get secret $${SECRET_NAME} -n $${NAMESPACE} -o jsonpath='{.data.IPMI_URL}' | base64 -d)
                  export IPMI_MODEL=\$(kubectl get secret $${SECRET_NAME} -n $${NAMESPACE} -o jsonpath='{.data.IPMI_MODEL}' | base64 -d)
                  export IPMI_USERNAME=\$(kubectl get secret $${SECRET_NAME} -n $${NAMESPACE} -o jsonpath='{.data.IPMI_USERNAME}' | base64 -d)
                  export IPMI_PASSWORD=\$(kubectl get secret $${SECRET_NAME} -n $${NAMESPACE} -o jsonpath='{.data.IPMI_PASSWORD}' | base64 -d)

                  echo "=== IPMI Configuration ==="
                  echo "IPMI URL: \$${IPMI_URL}"
                  echo "IPMI Model: \$${IPMI_MODEL}"
                  echo "IPMI Username: \$${IPMI_USERNAME}"

                  echo "=== Deploying certificate ==="
                  python3 /scripts/ipmi-updater.py \\
                    --ipmi-url "\$${IPMI_URL}" \\
                    --model "\$${IPMI_MODEL}" \\
                    --username "\$${IPMI_USERNAME}" \\
                    --password "\$${IPMI_PASSWORD}" \\
                    --cert-file /certs/cert.pem \\
                    --key-file /certs/key.pem
              volumeMounts:
                - name: scripts
                  mountPath: /scripts
                - name: certs
                  mountPath: /certs
          volumes:
            - name: scripts
              configMap:
                name: certwarden-ipmi-scripts
                defaultMode: 0755
            - name: certs
              secret:
                secretName: $${CERT_SECRET_NAME}
    EOF

    # Wait for the job to complete
    echo "Waiting for Job to complete..."
    kubectl wait --for=condition=complete --timeout=5m "job/$${JOB_NAME}" -n "$${NAMESPACE}"

    # Get the job logs
    echo "=== Job Logs ==="
    kubectl logs "job/$${JOB_NAME}" -n "$${NAMESPACE}"

    # Check if the job succeeded
    JOB_STATUS=$(kubectl get job "$${JOB_NAME}" -n "$${NAMESPACE}" -o jsonpath='{.status.conditions[?(@.type=="Complete")].status}')
    if [[ "$${JOB_STATUS}" == "True" ]]; then
        echo "✅ Certificate deployed successfully to $${IPMI_HOST}"
        exit 0
    else
        echo "❌ Failed to deploy certificate to $${IPMI_HOST}"
        kubectl logs "job/$${JOB_NAME}" -n "$${NAMESPACE}"
        exit 1
    fi
  ipmi-updater.py: "#!/usr/bin/env python3\n\n# vim: autoindent tabstop=4 shiftwidth=4 expandtab softtabstop=4 filetype=python\n\n# This file is part of Supermicro IPMI certificate updater.\n# Supermicro IPMI certificate updater is free software: you can\n# redistribute it and/or modify it under the terms of the GNU General Public\n# License as published by the Free Software Foundation, version 2.\n#\n# This program is distributed in the hope that it will be useful, but WITHOUT\n# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n# details.\n#\n# You should have received a copy of the GNU General Public License along with\n# this program; if not, write to the Free Software Foundation, Inc., 51\n# Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n#\n# Copyright (c) Jari Turkia\n\n\nimport os\nimport argparse\nimport re\nimport requests\nimport logging\nimport json\nfrom base64 import b64encode\nfrom datetime import datetime\nimport xml.etree.ElementTree as etree\nfrom urllib.parse import urlparse\n\nREQUEST_TIMEOUT = 5.0\n\nclass IPMIUpdater:\n    def __init__(self, session, ipmi_url):\n        self.session = session\n        self.ipmi_url = ipmi_url\n\n        self.login_url = f'{ipmi_url}/cgi/login.cgi'\n        self.cert_info_url = f'{ipmi_url}/cgi/ipmi.cgi'\n        self.upload_cert_url = f'{ipmi_url}/cgi/upload_ssl.cgi'\n        self.url_redirect_template = f'{ipmi_url}/cgi/url_redirect.cgi?url_name=%s'\n\n        self.use_b64encoded_login = True\n\n        self._csrf_token = None\n\n        error_log = logging.getLogger(\"IPMIUpdater\")\n        error_log.setLevel(logging.ERROR)\n        self.setLogger(error_log)\n\n    def setLogger(self, logger):\n        self.logger = logger\n\n    def get_csrf_token(self, url_name):\n        if self._csrf_token is not None:\n            return self._csrf_token\n        \n        page_url = self.url_redirect_template % url_name\n        result = self.session.get(page_url)\n        result.raise_for_status()\n\n        match = re.search(r'SmcCsrfInsert\\s*\\(\"CSRF_TOKEN\",\\s*\"([^\"]*)\"\\);', result.text)\n        if match:\n            return match.group(1)\n\n    def get_csrf_headers(self, url_name):\n        page_url = self.url_redirect_template % url_name\n\n        headers = {\n            \"Origin\": self.ipmi_url,\n            \"Referer\": page_url,\n        }\n        csrf_token = self.get_csrf_token(url_name)\n        if csrf_token is not None:\n            headers[\"CSRF_TOKEN\"] = csrf_token\n\n        self.logger.debug(\"HEADERS:%s\" % headers)\n        return headers\n\n    def get_xhr_headers(self, url_name):\n        headers = self.get_csrf_headers(url_name)\n        headers[\"X-Requested-With\"] = \"XMLHttpRequest\"\n        return headers\n\n    def login(self, username, password, model):\n        \"\"\"\n        Log into IPMI interface\n        :param username: username to use for logging in\n        :param password: password to use for logging in\n        :return: bool\n        \"\"\"\n        if model != \"X12\":\n            if self.use_b64encoded_login:\n                login_data = {\n                    'name': b64encode(username.encode(\"UTF-8\")),\n                    'pwd': b64encode(password.encode(\"UTF-8\")),\n                    'check': '00'\n                }\n            else:\n                login_data = {\n                    'name': username,\n                    'pwd': password\n                }\n\n            try:\n                result = self.session.post(self.login_url, login_data, timeout=REQUEST_TIMEOUT, verify=False)\n            except ConnectionError:\n                return False\n            if not result.ok:\n                return result.status_code\n            if '/cgi/url_redirect.cgi?url_name=mainmenu' not in result.text:\n                return False\n\n            # Set mandatory cookies:\n            url_parts = urlparse(self.ipmi_url)\n            # Cookie: langSetFlag=0; language=English; SID=<dynamic session ID here!>; mainpage=configuration; subpage=config_ssl\n            mandatory_cookies = {\n                'langSetFlag': '0',\n                'language': 'English'\n            }\n            for cookie_name, cookie_value in mandatory_cookies.items():\n                self.session.cookies.set(cookie_name, cookie_value, domain=url_parts.hostname)\n\n            return True\n        \n        else:\n            login_data = {\n                'UserName': username,\n                'Password': password\n            }\n            \n            request_headers = {'Content-Type': 'application/json'}\n            try:\n                result = self.session.post(self.login_url, data=json.dumps(login_data), headers=request_headers, timeout=REQUEST_TIMEOUT, verify=False)\n            except ConnectionError:\n                return False\n            if not result.ok:\n                return result.status_code\n\n            return result\n\n\n    def get_ipmi_cert_info(self, model, token):\n        \"\"\"\n        Verify existing certificate information\n        :return: dict\n        \"\"\"\n\n        if model == \"X12\":\n\n            request_headers = {\n                'Content-Type': 'application/json',\n                'X-Auth-Token': token\n            }\n\n            try:\n                r = self.session.get(self.cert_info_url, headers=request_headers, verify=False)\n            except ConnectionError:\n                return False\n            if not r.ok:\n                return False\n\n            data = r.json()\n\n            valid_from = datetime.strptime(data['VaildFrom'].rstrip(re.split(r'\\d{4}', data['VaildFrom'])[1]), r\"%b %d %H:%M:%S %Y\")\n            valid_until = datetime.strptime(data['GoodTHRU'].rstrip(re.split(r'\\d{4}', data['GoodTHRU'])[1]), r\"%b %d %H:%M:%S %Y\")\n\n            return  {\n                'has_cert': True,\n                'valid_from': valid_from,\n                'valid_until': valid_until\n            }\n\n        headers = self.get_xhr_headers(\"config_ssl\")\n\n        cert_info_data = self._get_op_data('SSL_STATUS.XML', '(0,0)')\n\n        try:\n            result = self.session.post(self.cert_info_url, cert_info_data, headers=headers, timeout=REQUEST_TIMEOUT, verify=False)\n        except ConnectionError:\n            return False\n        if not result.ok:\n            return False\n\n        self.logger.debug(result.text)\n        root = etree.fromstring(result.text)\n        # <?xml> <IPMI> <SSL_INFO> <STATUS>\n        status = root.findall('.//SSL_INFO/STATUS')\n        if not status:\n            return False\n        # Since xpath will return a list, just pick the first one from it.\n        status = status[0]\n        has_cert = bool(int(status.get('CERT_EXIST')))\n        if has_cert:\n            valid_from = datetime.strptime(status.get('VALID_FROM'), r\"%b %d %H:%M:%S %Y\")\n            valid_until = datetime.strptime(status.get('VALID_UNTIL'), r\"%b %d %H:%M:%S %Y\")\n\n        return {\n            'has_cert': has_cert,\n            'valid_from': valid_from,\n            'valid_until': valid_until\n        }\n\n    def get_ipmi_cert_valid(self):\n        \"\"\"\n        Verify existing certificate information\n        :return: bool\n        \"\"\"\n\n        headers = self.get_xhr_headers(\"config_ssl\")\n\n        cert_info_data = self._get_op_data('SSL_VALIDATE.XML', '(0,0)')\n\n        try:\n            result = self.session.post(self.cert_info_url, cert_info_data, headers=headers, timeout=REQUEST_TIMEOUT, verify=False)\n        except ConnectionError:\n            return False\n        if not result.ok:\n            return False\n\n        self.logger.debug(result.text)\n        root = etree.fromstring(result.text)\n        # <?xml> <IPMI> <SSL_INFO>\n        status = root.findall('.//SSL_INFO')\n        if not status:\n            return False\n        # Since xpath will return a list, just pick the first one from it.\n        status = status[0]\n        return bool(int(status.get('VALIDATE')))\n\n    def upload_cert(self, key_file, cert_file, model, token):\n        \"\"\"\n        Send X.509 certificate and private key to server\n        :param session: Current session object\n        :type session requests.session\n        :param url: base-URL to IPMI\n        :param key_file: filename to X.509 certificate private key\n        :param cert_file: filename to X.509 certificate PEM\n        :return:\n        \"\"\"\n        with open(key_file, 'rb') as filehandle:\n            key_data = filehandle.read()\n        with open(cert_file, 'rb') as filehandle:\n            cert_data = filehandle.read()\n            # extract certificates only (IMPI doesn't like DH PARAMS)\n            cert_data = b'\\n'.join(re.findall(b'-----BEGIN CERTIFICATE-----.*?-----END CERTIFICATE-----', cert_data, re.DOTALL)) + b'\\n'\n\n        if model == 'X12':\n            substr = b'-----END CERTIFICATE-----\\n'\n            cert_data = cert_data.split(substr)[0] + substr\n\n            files_to_upload = self._get_upload_data(cert_data, key_data)\n\n            request_headers = {'X-Auth-Token': token}\n\n            try:\n                result = self.session.post(self.upload_cert_url, files=files_to_upload, headers=request_headers, timeout=REQUEST_TIMEOUT, verify=False)\n            except ConnectionError:\n                return False\n\n            if not 'SSL certificate and private key were successfully uploaded' in result.text:\n                return False\n\n            return True\n\n\n        else:\n            files_to_upload = self._get_upload_data(cert_data, key_data)\n\n            headers = self.get_csrf_headers(\"config_ssl\")\n            csrf_token = self.get_csrf_token(\"config_ssl\")\n            csrf_data = {}\n            if csrf_token is not None:\n                csrf_data[\"CSRF_TOKEN\"] = csrf_token\n\n            try:\n                result = self.session.post(self.upload_cert_url, csrf_data, files=files_to_upload, headers=headers, timeout=REQUEST_TIMEOUT, verify=False)\n            except ConnectionError:\n                return False\n            if not result.ok:\n                return False\n\n\n            if 'Content-Type' not in result.headers.keys() or result.headers['Content-Type'] != 'text/html':\n                # On failure, Content-Type will be 'text/plain' and 'Transfer-Encoding' is 'chunked'\n                return False\n            if 'CONFPAGE_RESET' not in result.text:\n                return False\n\n            return True\n\n\n    def _check_reboot_result(self, result):\n        return True\n\n    def reboot_ipmi(self, model, token):\n\n        if model != 'X12':\n            # do we need a different Referer here?\n            headers = self.get_xhr_headers(\"config_ssl\")\n\n            reboot_data = self._get_op_data('main_bmcreset', None)\n\n            try:\n                result = self.session.post(self.reboot_url, reboot_data, headers=headers, timeout=REQUEST_TIMEOUT, verify=False)\n            except ConnectionError:\n                return False\n            if not result.ok:\n                return False\n\n            if not self._check_reboot_result(result):\n                return False\n            return True\n        else:\n            request_headers = {'X-Auth-Token': token}\n\n            try:\n                result = self.session.post(self.reboot_url, headers=request_headers, timeout=REQUEST_TIMEOUT, verify=False)\n            except ConnectionError:\n                return False\n            if not result.ok:\n                return False\n\n            return True\n\nclass IPMIX9Updater(IPMIUpdater):\n\n    class TLSv1HttpAdapter(requests.adapters.HTTPAdapter):\n        \"\"\"\"Transport adapter\" that allows us to use SSLv3.\"\"\"\n\n        def init_poolmanager(self, connections, maxsize, block=False):\n            import ssl\n            from urllib3.poolmanager import PoolManager\n            ctx = ssl.SSLContext(protocol=ssl.PROTOCOL_TLSv1)\n            ctx.load_default_certs()\n            ctx.set_ciphers('DEFAULT@SECLEVEL=1')\n            self.poolmanager = PoolManager(\n                num_pools=connections, maxsize=maxsize,\n                block=block, ssl_context=ctx)\n\n    def __init__(self, session, ipmi_url):\n        super().__init__(session, ipmi_url)\n        self.reboot_url = f'{ipmi_url}/cgi/BMCReset.cgi'\n        self.use_b64encoded_login = False\n        self.session.mount('https://', IPMIX9Updater.TLSv1HttpAdapter())\n\n    def _get_op_data(self, op, r):\n        timestamp = datetime.utcnow().strftime('%a %d %b %Y %H:%M:%S GMT')\n\n        data = {\n            'time_stamp': timestamp  # 'Thu Jul 12 2018 19:52:48 GMT+0300 (FLE Daylight Time)'\n        }\n        if r is not None:\n            data[op] = r\n        return data\n\n    def _get_upload_data(self, cert_data, key_data):\n        return [\n            ('sslcrt_file', ('cert.pem', cert_data, 'application/octet-stream')),\n            ('privkey_file', ('privkey.pem', key_data, 'application/octet-stream'))\n        ]\n\n    def _check_reboot_result(self, result):\n        self.logger.debug(result.text)\n        root = etree.fromstring(result.text)\n        # <?xml> <IPMI> <SSL_INFO>\n        status = root.findall('.//BMC_RESET/STATE')\n        if not status:\n            return False\n        if status[0].get('CODE') == 'OK':\n            return True\n        return False\n        #if '<STATE CODE=\"OK\"/>' not in result.text:\n        #    return False\n\n    def get_ipmi_cert_valid(self):\n        \"\"\"\n        Verify existing certificate information\n        :return: bool\n        \"\"\"\n\n        headers = self.get_xhr_headers(\"config_ssl\")\n\n        cert_info_data = self._get_op_data('SSL_VALIDATE.XML', '(0,0)')\n\n        try:\n            result = self.session.post(self.cert_info_url, cert_info_data, headers=headers, timeout=REQUEST_TIMEOUT, verify=False)\n        except ConnectionError:\n            return False\n        if not result.ok:\n            return False\n\n        self.logger.debug(result.text)\n        root = etree.fromstring(result.text)\n        # <?xml> <IPMI> <SSL_INFO> <VALIDATE>\n        status = root.findall('.//SSL_INFO/VALIDATE')\n        if not status:\n            return False\n        # Since xpath will return a list, just pick the first one from it.\n        status = status[0]\n        return bool(int(status.get('CERT'))) and bool(int(status.get('KEY')))\n\nclass IPMIX10Updater(IPMIUpdater):\n    def __init__(self, session, ipmi_url):\n        super().__init__(session, ipmi_url)\n        self.reboot_url = f'{ipmi_url}/cgi/BMCReset.cgi'\n        self.use_b64encoded_login = False\n\n    def _get_op_data(self, op, r):\n        timestamp = datetime.utcnow().strftime('%a %d %b %Y %H:%M:%S GMT')\n\n        data = {\n            'time_stamp': timestamp  # 'Thu Jul 12 2018 19:52:48 GMT+0300 (FLE Daylight Time)'\n        }\n        if r is not None:\n            data[op] = r\n        return data\n\n    def _get_upload_data(self, cert_data, key_data):\n        return [\n            ('cert_file', ('cert.pem', cert_data, 'application/octet-stream')),\n            ('key_file', ('privkey.pem', key_data, 'application/octet-stream'))\n        ]\n\n    def _check_reboot_result(self, result):\n        self.logger.debug(result.text)\n        root = etree.fromstring(result.text)\n        # <?xml> <IPMI> <SSL_INFO>\n        status = root.findall('.//BMC_RESET/STATE')\n        if not status:\n            return False\n        if status[0].get('CODE') == 'OK':\n            return True\n        return False\n        #if '<STATE CODE=\"OK\"/>' not in result.text:\n        #    return False\n\n\nclass IPMIX11Updater(IPMIUpdater):\n    def __init__(self, session, ipmi_url):\n        super().__init__(session, ipmi_url)\n        self.reboot_url = f'{ipmi_url}/cgi/op.cgi'\n        self.use_b64encoded_login = True\n\n    def _get_op_data(self, op, r):\n        data = {\n            'op': op\n        }\n\n        if r is not None:\n            data['r'] = r\n        data['_'] = ''\n        return data\n\n    def _get_upload_data(self, cert_data, key_data):\n        return [\n            ('cert_file', ('fullchain.pem', cert_data, 'application/octet-stream')),\n            ('key_file', ('privkey.pem', key_data, 'application/octet-stream'))\n        ]\n    \nclass IPMIX12Updater(IPMIUpdater):\n    def __init__(self, session, ipmi_url):\n        super().__init__(session, ipmi_url)\n        self.login_url = f'{ipmi_url}/redfish/v1/SessionService/Sessions'\n        self.cert_info_url = f'{ipmi_url}/redfish/v1/UpdateService/Oem/Supermicro/SSLCert'\n        self.upload_cert_url = f'{ipmi_url}/redfish/v1/UpdateService/Oem/Supermicro/SSLCert/Actions/SmcSSLCert.Upload'\n        self.reboot_url = f'{ipmi_url}/redfish/v1/Managers/1/Actions/Manager.Reset'\n        self.use_b64encoded_login = False\n\n    def _get_upload_data(self, cert_data, key_data):\n        return {\n            'cert_file' : cert_data,\n            'key_file' : key_data\n        }\n\ndef parse_valid_until(pem):\n    from datetime import datetime\n    from OpenSSL import crypto as c\n    with open(pem, 'rb') as fh:\n        cert = c.load_certificate(c.FILETYPE_PEM, fh.read())\n    return datetime.strptime(cert.get_notAfter().decode('utf8'), \"%Y%m%d%H%M%SZ\")\n\ndef create_updater(args):\n    session = requests.session()\n\n    if not args.quiet:\n        print(\"Board model is \" + args.model)\n\n    if args.model == \"X10\":\n        return IPMIX10Updater(session, args.ipmi_url)\n    elif args.model == \"X11\":\n        return IPMIX11Updater(session, args.ipmi_url)\n    elif args.model == \"X9\":\n        return IPMIX9Updater(session, args.ipmi_url)\n    elif args.model == \"X12\":\n        return IPMIX12Updater(session, args.ipmi_url)\n    else:\n        raise Exception(f\"Unknown model: {args.model}\")\n\ndef main():\n    parser = argparse.ArgumentParser(description='Update Supermicro IPMI SSL certificate')\n    parser.add_argument('--ipmi-url', required=True,\n                        help='Supermicro IPMI 2.0 URL')\n    parser.add_argument('--model', required=True,\n                        help='Board model: X9, X10, X11, X12, X13')\n    parser.add_argument('--key-file', required=True,\n                        help='X.509 Private key filename')\n    parser.add_argument('--cert-file', required=True,\n                        help='X.509 Certificate filename')\n    parser.add_argument('--username', required=True,\n                        help='IPMI username with admin access')\n    parser.add_argument('--password', required=True,\n                        help='IPMI user password')\n    parser.add_argument('--no-reboot', action='store_true',\n                        help='The default is to reboot the IPMI after upload for the change to take effect.')\n    parser.add_argument('--force-update', action='store_true',\n                        help='Ignore the cert end date check, always replace the cert.')\n    parser.add_argument('--quiet', action='store_true',\n                        help='Do not output anything if successful')\n    parser.add_argument('--debug', action='store_true',\n                        help='Output additional debugging')\n    args = parser.parse_args()\n\n    # Confirm args\n    if not os.path.isfile(args.key_file):\n        print(\"--key-file '%s' doesn't exist!\" % args.key_file)\n        exit(2)\n    if not os.path.isfile(args.cert_file):\n        print(\"--cert-file '%s' doesn't exist!\" % args.cert_file)\n        exit(2)\n    if args.ipmi_url[-1] == '/':\n        args.ipmi_url = args.ipmi_url[0:-1]\n\n    if args.debug:\n        import http.client as http_client\n        http_client.HTTPConnection.debuglevel = 1\n\n        # Enable request logging\n        logging.basicConfig()\n        logging.getLogger().setLevel(logging.DEBUG)\n        requests_log = logging.getLogger(\"requests.packages.urllib3\")\n        requests_log.setLevel(logging.DEBUG)\n        requests_log.propagate = True\n\n    if args.model == \"X13\":\n        args.model = \"X12\"\n\n    # Start the operation\n    requests.packages.urllib3.disable_warnings(requests.packages.urllib3.exceptions.InsecureRequestWarning)\n\n    updater = create_updater(args)\n    if args.debug:\n        debug_log = logging.getLogger(\"IPMIUpdater\")\n        debug_log.setLevel(logging.DEBUG)\n        updater.setLogger(debug_log)\n\n    login_response = updater.login(args.username, args.password, args.model)\n    if not login_response:\n        print(\"Login failed. Cannot continue!\")\n        exit(2)\n    elif args.model == 'X12':\n        try:\n            token = login_response.headers['X-Auth-Token']\n        except:\n            print(f'ERROR: Login failed with error {login_response}')\n            exit(2)\n    else:\n        token = None\n\n    cert_info = updater.get_ipmi_cert_info(args.model, token)\n    if not cert_info:\n        print(\"Failed to extract certificate information from IPMI!\")\n        exit(2)\n    current_valid_until = cert_info.get('valid_until', None)\n    if not args.quiet and cert_info['has_cert']:\n        print(\"There exists a certificate, which is valid until: %s\" % cert_info['valid_until'])\n    \n    new_valid_until = parse_valid_until(args.cert_file)\n    if current_valid_until == new_valid_until:\n        if not args.force_update:\n            print(\"New cert validity period matches existing cert, nothing to do\")\n            exit(0)\n        else:\n            print(\"New cert validity period matches existing cert, will update regardless\")\n\n    # Go upload!\n    if not updater.upload_cert(args.key_file, args.cert_file, args.model, token):\n        print(\"Failed to upload X.509 files to IPMI!\")\n        exit(2)\n\n    if args.model != 'X12':\n        cert_valid = updater.get_ipmi_cert_valid()\n        if not cert_valid:\n            print(\"Uploads failed validation\")\n            exit(2)\n\n    if not args.quiet:\n        print(\"Uploaded files ok.\")\n\n    cert_info = updater.get_ipmi_cert_info(args.model, token)\n    if not cert_info:\n        print(\"Failed to extract certificate information from IPMI!\")\n        exit(2)\n    if not args.quiet and cert_info['has_cert']:\n        print(\"After upload, there exists a certificate, which is valid until: %s\" % cert_info['valid_until'])\n\n    if not args.no_reboot:\n        if not args.quiet:\n            print(\"Rebooting IPMI to apply changes.\")\n        if not updater.reboot_ipmi(args.model, token):\n            print(\"Rebooting failed! Go reboot it manually?\")\n\n    if not args.quiet:\n        print(\"All done!\")\n\n\nif __name__ == \"__main__\":\n    main()\n\n"
kind: ConfigMap
metadata:
  creationTimestamp: null
  name: certwarden-ipmi-scripts
  namespace: infrastructure
